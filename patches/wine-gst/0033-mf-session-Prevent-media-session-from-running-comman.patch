From f6f245f7f84b231c2a033ed82ed3de6d9a278c91 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Mon, 29 Jul 2024 04:21:03 +0200
Subject: [PATCH 33/52] mf/session: Prevent media session from running commands
 concurrently.

CW-Bug-Id: #24115
---
 dlls/mf/session.c | 108 ++++++++++++++++++++++++++--------------------
 1 file changed, 61 insertions(+), 47 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 49733fd9e87..c07d28e95ae 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -223,6 +223,7 @@ enum presentation_flags
     SESSION_FLAG_END_OF_PRESENTATION = 0x10,
     SESSION_FLAG_PENDING_RATE_CHANGE = 0x20,
     SESSION_FLAG_PENDING_COMMAND = 0x40,
+    SESSION_FLAG_QUEUED_COMMAND = 0x80,
 };
 
 struct media_session
@@ -465,6 +466,35 @@ static HRESULT session_is_shut_down(struct media_session *session)
     return session->state == SESSION_STATE_SHUT_DOWN ? MF_E_SHUTDOWN : S_OK;
 }
 
+static void session_schedule_command(struct media_session *session)
+{
+    struct session_op *op;
+    struct list *e;
+    HRESULT hr;
+
+    if (session->presentation.flags & (SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND))
+    {
+        TRACE("not queueing: flags %x\n", session->presentation.flags);
+        return;
+    }
+
+    if (session->state != SESSION_STATE_STOPPED && session->state != SESSION_STATE_STARTED &&
+        session->state != SESSION_STATE_PAUSED && session->state != SESSION_STATE_CLOSED &&
+        session->state != SESSION_STATE_SHUT_DOWN)
+    {
+        TRACE("not queueing: state %x\n", session->state);
+        return;
+    }
+
+    if ((e = list_head(&session->commands)))
+    {
+        op = LIST_ENTRY(e, struct session_op, entry);
+        hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
+        session->presentation.flags |= SESSION_FLAG_QUEUED_COMMAND;
+        op->submitted = SUCCEEDED(hr);
+    }
+}
+
 static HRESULT session_submit_command(struct media_session *session, struct session_op *op)
 {
     HRESULT hr;
@@ -474,16 +504,12 @@ static HRESULT session_submit_command(struct media_session *session, struct sess
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        if (list_empty(&session->commands) && !(session->presentation.flags & SESSION_FLAG_PENDING_COMMAND))
-        {
-            hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
-            op->submitted = SUCCEEDED(hr);
-        }
         if (op->command == SESSION_CMD_SHUTDOWN)
             list_add_head(&session->commands, &op->entry);
         else
             list_add_tail(&session->commands, &op->entry);
         IUnknown_AddRef(&op->IUnknown_iface);
+        session_schedule_command(session);
     }
     LeaveCriticalSection(&session->cs);
 
@@ -969,19 +995,10 @@ static struct topo_node *session_get_topo_node_output(const struct media_session
 
 static void session_command_complete(struct media_session *session)
 {
-    struct session_op *op;
-    struct list *e;
-    HRESULT hr;
-
-    session->presentation.flags &= ~SESSION_FLAG_PENDING_COMMAND;
+    session->presentation.flags &= ~(SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND);
 
     /* Submit next command. */
-    if ((e = list_head(&session->commands)))
-    {
-        op = LIST_ENTRY(e, struct session_op, entry);
-        hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
-        op->submitted = SUCCEEDED(hr);
-    }
+    session_schedule_command(session);
 }
 
 static void session_command_complete_with_event(struct media_session *session, MediaEventType event,
@@ -1074,23 +1091,6 @@ static void session_flush_nodes(struct media_session *session)
     }
 }
 
-static void session_set_source_output_nodes_seeking(struct media_session *session)
-{
-    struct media_source *source;
-    struct topo_node *node;
-
-    LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
-    {
-        source->state = OBJ_STATE_SEEKING;
-    }
-
-    LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
-    {
-        if (node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || node->type == MF_TOPOLOGY_OUTPUT_NODE)
-            node->state = OBJ_STATE_SEEKING;
-    }
-}
-
 static void session_start(struct media_session *session, const GUID *time_format, const PROPVARIANT *start_position)
 {
     struct media_source *source;
@@ -1113,6 +1113,9 @@ static void session_start(struct media_session *session, const GUID *time_format
             /* fallthrough */
         case SESSION_STATE_PAUSED:
         case SESSION_STATE_STARTED:
+        {
+            enum session_state new_state = SESSION_STATE_STARTED;
+
             session->presentation.time_format = *time_format;
             session->presentation.start_position.vt = VT_EMPTY;
             PropVariantCopy(&session->presentation.start_position, start_position);
@@ -1153,6 +1156,12 @@ static void session_start(struct media_session *session, const GUID *time_format
                     session_handle_start_error(session, hr);
                     return;
                 }
+
+                if (start_position->vt != VT_EMPTY)
+                    source->state = OBJ_STATE_SEEKING;
+
+                if (source->state != OBJ_STATE_STARTED)
+                    new_state = SESSION_STATE_STARTING_SOURCES;
             }
 
             LIST_FOR_EACH_ENTRY(topo_node, &session->presentation.nodes, struct topo_node, entry)
@@ -1165,12 +1174,17 @@ static void session_start(struct media_session *session, const GUID *time_format
                         stream->draining = FALSE;
                     }
                 }
+                else if (start_position->vt != VT_EMPTY)
+                {
+                    if (topo_node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || topo_node->type == MF_TOPOLOGY_OUTPUT_NODE)
+                        topo_node->state = OBJ_STATE_SEEKING;
+                }
             }
 
             session_flush_nodes(session);
-            session_set_source_output_nodes_seeking(session);
-            session->state = SESSION_STATE_STARTING_SOURCES;
+            session_set_state(session, new_state);
             break;
+        }
         default:
             session_command_complete_with_event(session, MESessionStarted, MF_E_INVALIDREQUEST, NULL);
             break;
@@ -1184,7 +1198,7 @@ static void session_set_started(struct media_session *session)
     unsigned int caps;
     DWORD flags;
 
-    session->state = SESSION_STATE_STARTED;
+    session_set_state(session, SESSION_STATE_STARTED);
 
     caps = session->caps | MFSESSIONCAP_PAUSE;
 
@@ -1216,7 +1230,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
     /* Failed event status could indicate a failure during normal transition to paused state,
        or an attempt to pause from invalid initial state. To finalize failed transition in the former case,
        state is still forced to PAUSED, otherwise previous state is retained. */
-    if (state != ~0u) session->state = state;
+    if (state != ~0u) session_set_state(session, state);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~MFSESSIONCAP_PAUSE);
     session_command_complete_with_event(session, MESessionPaused, status, NULL);
@@ -1224,7 +1238,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
 
 static void session_set_closed(struct media_session *session, HRESULT status)
 {
-    session->state = SESSION_STATE_CLOSED;
+    session_set_state(session, SESSION_STATE_CLOSED);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~(MFSESSIONCAP_START | MFSESSIONCAP_SEEK));
     session_command_complete_with_event(session, MESessionClosed, status, NULL);
@@ -1241,7 +1255,7 @@ static void session_pause(struct media_session *session)
 
             /* Transition in two steps - pause the clock, wait for sinks, then pause sources. */
             if (SUCCEEDED(hr = IMFPresentationClock_Pause(session->clock)))
-                session->state = SESSION_STATE_PAUSING_SINKS;
+                session_set_state(session, SESSION_STATE_PAUSING_SINKS);
             state = SESSION_STATE_PAUSED;
 
             break;
@@ -1279,7 +1293,7 @@ static void session_set_stopped(struct media_session *session, HRESULT status)
     MediaEventType event_type;
     IMFMediaEvent *event;
 
-    session->state = SESSION_STATE_STOPPED;
+    session_set_state(session, SESSION_STATE_STOPPED);
     event_type = session->presentation.flags & SESSION_FLAG_END_OF_PRESENTATION ? MESessionEnded : MESessionStopped;
 
     if (SUCCEEDED(MFCreateMediaEvent(event_type, &GUID_NULL, status, NULL, &event)))
@@ -1304,7 +1318,7 @@ static void session_stop(struct media_session *session)
             /* Transition in two steps - stop the clock, wait for sinks, then stop sources. */
             IMFPresentationClock_GetTime(session->clock, &session->presentation.clock_stop_time);
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             else
                 session_set_stopped(session, hr);
 
@@ -1326,7 +1340,7 @@ static HRESULT session_finalize_sinks(struct media_session *session)
     HRESULT hr = S_OK;
 
     session->presentation.flags &= ~SESSION_FLAG_FINALIZE_SINKS;
-    session->state = SESSION_STATE_FINALIZING_SINKS;
+    session_set_state(session, SESSION_STATE_FINALIZING_SINKS);
 
     LIST_FOR_EACH_ENTRY(sink, &session->presentation.sinks, struct media_sink, entry)
     {
@@ -1362,7 +1376,7 @@ static void session_close(struct media_session *session)
         case SESSION_STATE_PAUSED:
             session->presentation.flags |= SESSION_FLAG_FINALIZE_SINKS;
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             break;
         default:
             hr = MF_E_INVALIDREQUEST;
@@ -2497,7 +2511,7 @@ static HRESULT WINAPI mfsession_Shutdown(IMFMediaSession *iface)
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        session->state = SESSION_STATE_SHUT_DOWN;
+        session_set_state(session, SESSION_STATE_SHUT_DOWN);
         IMFMediaEventQueue_Shutdown(session->event_queue);
         if (session->quality_manager)
             IMFQualityManager_Shutdown(session->quality_manager);
@@ -3311,10 +3325,10 @@ static void session_set_source_object_state(struct media_session *session, IUnkn
                         }
                     }
                 }
-                session->state = SESSION_STATE_PREROLLING_SINKS;
+                session_set_state(session, SESSION_STATE_PREROLLING_SINKS);
             }
             else if (SUCCEEDED(session_start_clock(session)))
-                session->state = SESSION_STATE_STARTING_SINKS;
+                session_set_state(session, SESSION_STATE_STARTING_SINKS);
 
             break;
         case SESSION_STATE_PAUSING_SOURCES:
@@ -3362,7 +3376,7 @@ static void session_set_sink_stream_state(struct media_session *session, IMFStre
                 break;
 
             if (SUCCEEDED(session_start_clock(session)))
-                session->state = SESSION_STATE_STARTING_SINKS;
+                session_set_state(session, SESSION_STATE_STARTING_SINKS);
             break;
         case SESSION_STATE_STARTING_SINKS:
             if (!session_is_output_nodes_state(session, OBJ_STATE_STARTED))
-- 
2.47.2

